<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>ÌÖåÏä§Ìä∏ ÌîåÎ†àÏù¥</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body { 
      overflow: hidden; 
      background: #1a1a2e; 
      font-family: sans-serif;
      height: 100vh;
      max-height: 100vh;
    }
    
    #game-container {
      display: flex;
      width: 100%;
      height: calc(100vh - 40px);
      max-height: calc(100vh - 40px);
    }
    
    #video-area {
      width: 55%;
      height: 100%;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }
    
    #video-bg {
      width: 100%;
      height: 100%;
      object-fit: contain;
      filter: brightness(0.85);
    }
    
    #notes-area {
      width: 45%;
      height: 100%;
      background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%);
      position: relative;
      border-left: 3px solid #4d96ff;
    }
    
    #notes-layer {
      width: 100%;
      height: 100%;
    }
    
    #ui-layer {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
    }
    
    #score-display {
      position: absolute;
      top: 20px; right: 20px;
      color: white;
      font-size: 28px;
      font-weight: bold;
      text-shadow: 2px 2px 4px black;
    }
    
    #combo-display {
      position: absolute;
      top: 60px; right: 20px;
      color: #ffd93d;
      font-size: 22px;
      font-weight: bold;
      text-shadow: 2px 2px 4px black;
    }
    
    #judgment-display {
      position: absolute;
      top: 40%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 52px;
      font-weight: bold;
      text-shadow: 3px 3px 6px black;
      opacity: 0;
      transition: opacity 0.1s;
    }
    
    #key-hints {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 30px;
    }
    
    .key-hint {
      width: 90px;
      height: 90px;
      border: 4px solid white;
      border-radius: 15px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 36px;
      font-weight: bold;
      color: white;
      background: rgba(0,0,0,0.6);
      transition: all 0.1s;
    }
    
    .key-hint[data-key="D"] {
      border-color: #ff6b6b;
      box-shadow: 0 0 15px rgba(255,107,107,0.5);
    }
    
    .key-hint[data-key="F"] {
      border-color: #4d96ff;
      box-shadow: 0 0 15px rgba(77,150,255,0.5);
    }
    
    .key-hint.active {
      background: rgba(255,255,0,0.8);
      transform: scale(1.1);
    }
    
    #start-btn {
      position: absolute;
      top: 50%;
      left: 27.5%;
      transform: translate(-50%, -50%);
      z-index: 10;
      padding: 25px 50px;
      font-size: 28px;
      font-weight: bold;
      background: linear-gradient(135deg, #ff6b6b, #ff8e8e);
      color: white;
      border: none;
      border-radius: 15px;
      cursor: pointer;
      pointer-events: auto;
      box-shadow: 0 5px 20px rgba(255,107,107,0.5);
      transition: all 0.2s;
    }
    
    #start-btn:hover {
      background: linear-gradient(135deg, #ff5252, #ff6b6b);
      transform: translate(-50%, -50%) scale(1.05);
    }
    
    #loading {
      position: absolute;
      top: 50%;
      left: 27.5%;
      transform: translate(-50%, -50%);
      z-index: 10;
      color: white;
      font-size: 24px;
      display: none;
    }
    
    #hit-line-area {
      position: absolute;
      bottom: 130px;
      left: 0;
      width: 100%;
      height: 5px;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.8), transparent);
    }
  </style>
</head>
<body>
  <div id="game-container">
    <div id="video-area">
      <video id="video-bg"></video>
      <button id="start-btn">‚ñ∂ ÏãúÏûëÌïòÍ∏∞</button>
      <div id="loading">üéµ ÎπÑÌä∏ Î∂ÑÏÑù Ï§ë... Ïû†ÏãúÎßå Í∏∞Îã§Î†§Ï£ºÏÑ∏Ïöî!</div>
    </div>
    
    <div id="notes-area">
      <canvas id="notes-layer"></canvas>
      <div id="ui-layer">
        <div id="score-display">SCORE: 0</div>
        <div id="combo-display">COMBO: 0</div>
        <div id="judgment-display"></div>
        <div id="hit-line-area"></div>
        <div id="key-hints">
          <div class="key-hint" data-key="D">D</div>
          <div class="key-hint" data-key="F">F</div>
        </div>
      </div>
    </div>
  </div>
  
  <script>
    const VIDEO_URL = "https://res.cloudinary.com/danknjfhv/video/upload/v1766605968/%EC%99%9C%ED%81%B4%EB%A6%AD_%EB%A9%94%EC%9D%B4%ED%94%8C_AI_%EB%B3%B8%EC%84%AD_%EC%9C%A0%EC%A0%80%EB%93%A4%EC%9D%B4_%EB%AD%98_%ED%96%88%EB%8B%A4%EA%B3%A0_ooya98go318_url4h2.mp4";
    
    const SOUND_URL = {
      hit: "https://res.cloudinary.com/danknjfhv/video/upload/v1766607567/Firework_blast_far_w8escv.ogg"
    };
    
    let audioContext = null;
    let hitSoundBuffer = null;
    
    async function loadSounds() {
      try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const response = await fetch(SOUND_URL.hit);
        const arrayBuffer = await response.arrayBuffer();
        hitSoundBuffer = await audioContext.decodeAudioData(arrayBuffer);
        console.log("Ìö®Í≥ºÏùå Î°úÎìú ÏôÑÎ£å!");
      } catch (e) {
        console.log("Ìö®Í≥ºÏùå Î°úÎìú Ïã§Ìå®:", e);
      }
    }
    
    function playHitSound() {
      if (audioContext && hitSoundBuffer) {
        const source = audioContext.createBufferSource();
        source.buffer = hitSoundBuffer;
        const gainNode = audioContext.createGain();
        gainNode.gain.value = 5.0;
        source.connect(gainNode);
        gainNode.connect(audioContext.destination);
        source.start(0);
      }
    }
    
    class BeatDetector {
      constructor(options = {}) {
        this.threshold = options.threshold || 0.6;
        this.minInterval = options.minInterval || 300;
      }

      async detectBeats(audioPath) {
        const tempContext = new (window.AudioContext || window.webkitAudioContext)();
        const response = await fetch(audioPath);
        const arrayBuffer = await response.arrayBuffer();
        const audioBuffer = await tempContext.decodeAudioData(arrayBuffer);
        const monoData = this.convertToMono(audioBuffer);
        const peaks = this.findPeaks(monoData, audioBuffer.sampleRate);
        const notes = this.generateNotes(peaks);
        tempContext.close();
        return notes;
      }

      convertToMono(audioBuffer) {
        const numberOfChannels = audioBuffer.numberOfChannels;
        if (numberOfChannels === 1) {
          return audioBuffer.getChannelData(0);
        }
        const left = audioBuffer.getChannelData(0);
        const right = audioBuffer.getChannelData(1);
        const mono = new Float32Array(left.length);
        for (let i = 0; i < left.length; i++) {
          mono[i] = (left[i] + right[i]) / 2;
        }
        return mono;
      }

      findPeaks(monoData, sampleRate) {
        const peaks = [];
        const chunkSize = Math.floor(sampleRate * 0.05);
        const minSamples = Math.floor(sampleRate * this.minInterval / 1000);
        let lastPeakIndex = -minSamples;
        let totalSum = 0;
        for (let i = 0; i < monoData.length; i++) {
          totalSum += Math.abs(monoData[i]);
        }
        const avgVolume = totalSum / monoData.length;
        const dynamicThreshold = avgVolume * (1 + this.threshold);
        for (let i = 0; i < monoData.length; i += chunkSize) {
          let chunkSum = 0;
          const end = Math.min(i + chunkSize, monoData.length);
          for (let j = i; j < end; j++) {
            chunkSum += Math.abs(monoData[j]);
          }
          const chunkAvg = chunkSum / (end - i);
          if (chunkAvg > dynamicThreshold && (i - lastPeakIndex) > minSamples) {
            const timeInSeconds = i / sampleRate;
            peaks.push(timeInSeconds);
            lastPeakIndex = i;
          }
        }
        return peaks;
      }

      generateNotes(peaks) {
        const keys = ['D', 'F'];
        const notes = [];
        for (let i = 0; i < peaks.length; i++) {
          const keyIndex = i % keys.length;
          notes.push({
            time: peaks[i],
            key: keys[keyIndex]
          });
        }
        return notes;
      }
    }

    const DIFFICULTY = {
      EASY: { threshold: 0.8, minInterval: 500 },
      NORMAL: { threshold: 0.5, minInterval: 300 },
      HARD: { threshold: 0.3, minInterval: 150 }
    };
    
    const LANE_KEYS = ['D', 'F'];
    const LANE_COLORS = ['#ff6b6b', '#4d96ff'];
    const NOTE_WIDTH = 90;
    const NOTE_HEIGHT = 30;
    const HIT_LINE_Y_RATIO = 0.82;
    
    // ÎÖ∏Ìä∏Í∞Ä ÌôîÎ©¥ ÏúÑÏóêÏÑú ÌûàÌä∏Ï°¥ÍπåÏßÄ ÎÇ¥Î†§Ïò§Îäî ÏãúÍ∞Ñ (Ï¥à)
    const NOTE_TRAVEL_TIME = 1.5;
    
    const JUDGMENT = {
      PERFECT: { threshold: 300, score: 100, color: '#ffff00', text: 'PERFECT!' },
      GOOD: { threshold: 600, score: 50, color: '#00ff00', text: 'GOOD!' },
      MISS: { threshold: 800, score: 0, color: '#ff0000', text: 'MISS' }
    };
    
    let score = 0;
    let combo = 0;
    let maxCombo = 0;
    let notes = [];
    let isPlaying = false;
    let hitLineY = 0;
    let noteSpeed = 0;
    
    const video = document.getElementById("video-bg");
    const canvas = document.getElementById("notes-layer");
    const ctx = canvas.getContext("2d");
    const scoreDisplay = document.getElementById("score-display");
    const comboDisplay = document.getElementById("combo-display");
    const judgmentDisplay = document.getElementById("judgment-display");
    const startBtn = document.getElementById("start-btn");
    const loadingDiv = document.getElementById("loading");
    const notesArea = document.getElementById("notes-area");
    
    function resizeCanvas() {
      canvas.width = notesArea.clientWidth;
      canvas.height = notesArea.clientHeight;
      hitLineY = canvas.height * HIT_LINE_Y_RATIO;
      // ÎÖ∏Ìä∏ ÏÜçÎèÑ = ÌûàÌä∏Ï°¥ÍπåÏßÄ Í±∞Î¶¨ / Ïù¥Îèô ÏãúÍ∞Ñ
      noteSpeed = hitLineY / NOTE_TRAVEL_TIME;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    function getLaneX(laneIndex) {
      const totalWidth = LANE_KEYS.length * (NOTE_WIDTH + 40);
      const startX = (canvas.width - totalWidth) / 2;
      return startX + laneIndex * (NOTE_WIDTH + 40);
    }
    
    async function init() {
      video.src = VIDEO_URL;
      video.crossOrigin = "anonymous";
      console.log("Ï¥àÍ∏∞Ìôî ÏôÑÎ£å!");
    }
    
    async function analyzeAndStart() {
      startBtn.style.display = "none";
      loadingDiv.style.display = "block";
      try {
        await loadSounds();
        const detector = new BeatDetector(DIFFICULTY.HARD);
        const detectedNotes = await detector.detectBeats(VIDEO_URL);
        notes = detectedNotes.map(note => ({
          ...note,
          hit: false,
          missed: false
        }));
        console.log("ÎπÑÌä∏ Î∂ÑÏÑù ÏôÑÎ£å! ÎÖ∏Ìä∏ Ïàò:", notes.length);
        loadingDiv.style.display = "none";
        startGame();
      } catch (e) {
        console.error("ÎπÑÌä∏ Î∂ÑÏÑù Ïã§Ìå®:", e);
        loadingDiv.textContent = "‚ö†Ô∏è Î∂ÑÏÑù Ïã§Ìå®! ÌéòÏù¥ÏßÄ ÏÉàÎ°úÍ≥†Ïπ® Ìï¥Ï£ºÏÑ∏Ïöî.";
      }
    }
    
    function startGame() {
      video.play();
      isPlaying = true;
      render();
    }
    
    function render() {
      if (!isPlaying) return;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // ÎπÑÎîîÏò§ ÌòÑÏû¨ ÏãúÍ∞Ñ = ÏùåÏïÖ Ïã±ÌÅ¨Ïùò Í∏∞Ï§Ä!
      const currentTime = video.currentTime;
      
      // Î†àÏù∏ Î∞∞Í≤Ω
      LANE_KEYS.forEach((key, index) => {
        const x = getLaneX(index);
        ctx.fillStyle = 'rgba(255,255,255,0.05)';
        ctx.fillRect(x - 5, 0, NOTE_WIDTH + 10, canvas.height);
      });
      
      // ÌûàÌä∏ÎùºÏù∏
      ctx.strokeStyle = "rgba(255, 255, 255, 0.8)";
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(getLaneX(0) - 20, hitLineY);
      ctx.lineTo(getLaneX(1) + NOTE_WIDTH + 20, hitLineY);
      ctx.stroke();
      
      notes.forEach((note, index) => {
        if (note.hit || note.missed) return;
        const laneIndex = LANE_KEYS.indexOf(note.key);
        if (laneIndex === -1) return;
        const x = getLaneX(laneIndex);
        
        // ÌïµÏã¨ Í≥ÑÏÇ∞:
        // - note.time = ÎπÑÌä∏Í∞Ä Î∞úÏÉùÌïòÎäî ÏãúÍ∞Ñ (ÌûàÌä∏Ï°¥Ïóê ÎèÑÏ∞©Ìï¥Ïïº ÌïòÎäî ÏãúÍ∞Ñ)
        // - currentTime = ÌòÑÏû¨ ÎπÑÎîîÏò§ ÏãúÍ∞Ñ
        // - ÎÖ∏Ìä∏Îäî note.time - NOTE_TRAVEL_TIME Ïóê ÌôîÎ©¥ Îß® ÏúÑ(y=0)ÏóêÏÑú Ï∂úÎ∞ú
        // - ÎÖ∏Ìä∏Îäî note.time Ïóê ÌûàÌä∏Ï°¥(y=hitLineY)Ïóê ÎèÑÏ∞©
        
        const timeUntilHit = note.time - currentTime; // ÌûàÌä∏ÍπåÏßÄ ÎÇ®ÏùÄ ÏãúÍ∞Ñ
        
        // y ÏúÑÏπò: ÌûàÌä∏Ï°¥ÏóêÏÑú (ÎÇ®ÏùÄÏãúÍ∞Ñ * ÏÜçÎèÑ) ÎßåÌÅº ÏúÑ
        // timeUntilHit > 0 Ïù¥Î©¥ ÏïÑÏßÅ ÌûàÌä∏Ï°¥ ÏúÑÏóê ÏûàÏùå
        // timeUntilHit = 0 Ïù¥Î©¥ Ï†ïÌôïÌûà ÌûàÌä∏Ï°¥
        // timeUntilHit < 0 Ïù¥Î©¥ ÌûàÌä∏Ï°¥ ÏïÑÎûòÎ°ú ÏßÄÎÇòÍ∞ê
        const y = hitLineY - (timeUntilHit * noteSpeed);
        
        // ÏïÑÏßÅ ÌôîÎ©¥ ÏúÑÏóê Ïïà ÎÇòÌÉÄÎÇú ÎÖ∏Ìä∏ (ÎÑàÎ¨¥ Ïù¥Î•∏ ÎÖ∏Ìä∏)
        if (y < -NOTE_HEIGHT) return;
        
        // ÌûàÌä∏Ï°¥ ÏïÑÎûòÎ°ú ÎÑàÎ¨¥ Î≤óÏñ¥ÎÇú ÎÖ∏Ìä∏Îäî MISS
        const missY = hitLineY + (JUDGMENT.MISS.threshold / 1000) * noteSpeed;
        if (y > missY) {
          handleMiss(index);
          return;
        }
        
        // ÎÖ∏Ìä∏ Í∑∏Î¶¨Í∏∞
        ctx.fillStyle = LANE_COLORS[laneIndex];
        ctx.beginPath();
        ctx.roundRect(x, y, NOTE_WIDTH, NOTE_HEIGHT, 8);
        ctx.fill();
        ctx.strokeStyle = "white";
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.fillStyle = "white";
        ctx.font = "bold 18px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText(note.key, x + NOTE_WIDTH/2, y + NOTE_HEIGHT/2 + 6);
      });
      
      requestAnimationFrame(render);
    }
    
    function handleKeyPress(key) {
      if (!isPlaying) return;
      
      const currentTime = video.currentTime;
      const keyUpper = key.toUpperCase();
      
      let closestNote = null;
      let closestDiff = Infinity;
      let closestIndex = -1;
      
      notes.forEach((note, index) => {
        if (note.hit || note.missed) return;
        if (note.key !== keyUpper) return;
        // Î∞ÄÎ¶¨Ï¥à Îã®ÏúÑÎ°ú Ï∞®Ïù¥ Í≥ÑÏÇ∞
        const diff = Math.abs(note.time - currentTime) * 1000;
        if (diff < closestDiff) {
          closestDiff = diff;
          closestNote = note;
          closestIndex = index;
        }
      });
      
      if (!closestNote) return;
      
      if (closestDiff <= JUDGMENT.PERFECT.threshold) {
        handleHit(closestIndex, JUDGMENT.PERFECT);
      } else if (closestDiff <= JUDGMENT.GOOD.threshold) {
        handleHit(closestIndex, JUDGMENT.GOOD);
      } else if (closestDiff <= JUDGMENT.MISS.threshold) {
        handleMiss(closestIndex);
      }
    }
    
    function handleHit(index, judgment) {
      notes[index].hit = true;
      combo++;
      if (combo > maxCombo) maxCombo = combo;
      score += judgment.score * (1 + combo * 0.01);
      playHitSound();
      updateUI();
      showJudgment(judgment.text, judgment.color);
    }
    
    function handleMiss(index) {
      notes[index].missed = true;
      combo = 0;
      updateUI();
      showJudgment(JUDGMENT.MISS.text, JUDGMENT.MISS.color);
    }
    
    function updateUI() {
      scoreDisplay.textContent = "SCORE: " + Math.floor(score);
      comboDisplay.textContent = "COMBO: " + combo;
    }
    
    function showJudgment(text, color) {
      judgmentDisplay.textContent = text;
      judgmentDisplay.style.color = color;
      judgmentDisplay.style.opacity = 1;
      setTimeout(() => {
        judgmentDisplay.style.opacity = 0;
      }, 300);
    }
    
    document.addEventListener("keydown", (e) => {
      const key = e.key.toUpperCase();
      if (LANE_KEYS.includes(key)) {
        handleKeyPress(key);
        const hint = document.querySelector(`.key-hint[data-key="${key}"]`);
        if (hint) hint.classList.add("active");
      }
    });
    
    document.addEventListener("keyup", (e) => {
      const key = e.key.toUpperCase();
      const hint = document.querySelector(`.key-hint[data-key="${key}"]`);
      if (hint) hint.classList.remove("active");
    });
    
    startBtn.addEventListener("click", analyzeAndStart);
    window.onload = init;
  </script>
</body>
</html>