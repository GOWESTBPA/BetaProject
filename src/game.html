<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Î¶¨Îì¨Í≤åÏûÑ - ÌîåÎ†àÏù¥</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body { 
      overflow: hidden; 
      background: #1a1a2e; 
      font-family: 'Segoe UI', sans-serif;
      height: 100vh;
      max-height: 100vh;
    }
    
    #game-container {
      display: flex;
      width: 100%;
      height: 100vh;
    }
    
    #video-area {
      width: 55%;
      height: 100%;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }
    
    #video-bg {
      width: 100%;
      height: 100%;
      object-fit: contain;
      filter: brightness(0.85);
    }
    
    #notes-area {
      width: 45%;
      height: 100%;
      background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%);
      position: relative;
      border-left: 3px solid #4d96ff;
    }
    
    #notes-layer {
      width: 100%;
      height: 100%;
    }
    
    #ui-layer {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
    }
    
    #score-display {
      position: absolute;
      top: 20px; right: 20px;
      color: white;
      font-size: 28px;
      font-weight: bold;
      text-shadow: 2px 2px 4px black;
    }
    
    #combo-display {
      position: absolute;
      top: 60px; right: 20px;
      color: #ffd93d;
      font-size: 22px;
      font-weight: bold;
      text-shadow: 2px 2px 4px black;
    }
    
    #judgment-display {
      position: absolute;
      top: 40%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 52px;
      font-weight: bold;
      text-shadow: 3px 3px 6px black;
      opacity: 0;
      transition: opacity 0.1s;
    }
    
    #key-hints {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 30px;
    }
    
    .key-hint {
      width: 90px;
      height: 90px;
      border: 4px solid white;
      border-radius: 15px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 36px;
      font-weight: bold;
      color: white;
      background: rgba(0,0,0,0.6);
      transition: all 0.1s;
    }
    
    .key-hint[data-key="D"] {
      border-color: #ff6b6b;
      box-shadow: 0 0 15px rgba(255,107,107,0.5);
    }
    
    .key-hint[data-key="F"] {
      border-color: #4d96ff;
      box-shadow: 0 0 15px rgba(77,150,255,0.5);
    }
    
    .key-hint.active {
      background: rgba(255,255,0,0.8);
      transform: scale(1.1);
    }
    
    #loading {
      position: absolute;
      top: 50%;
      left: 27.5%;
      transform: translate(-50%, -50%);
      z-index: 10;
      color: white;
      font-size: 24px;
      display: block;
    }
    
    #countdown {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 120px;
      font-weight: bold;
      color: white;
      text-shadow: 0 0 30px rgba(255, 107, 107, 0.8);
      z-index: 100;
      display: none;
    }
    
    #countdown.active {
      display: block;
      animation: countPulse 0.5s ease-out;
    }
    
    @keyframes countPulse {
      0% { transform: translate(-50%, -50%) scale(1.5); opacity: 0; }
      50% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
      100% { transform: translate(-50%, -50%) scale(0.9); opacity: 0.8; }
    }
    
    /* Í≤∞Í≥º ÌôîÎ©¥ */
    #result-screen {
      display: none;
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.9);
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    
    #result-screen.active {
      display: flex;
    }
    
    #result-screen h2 {
      font-size: 60px;
      color: #ffd93d;
      margin-bottom: 40px;
      text-shadow: 0 0 30px rgba(255, 217, 61, 0.5);
    }
    
    .result-box {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 20px;
      padding: 40px 60px;
      text-align: center;
      margin-bottom: 30px;
    }
    
    .result-score {
      font-size: 48px;
      font-weight: bold;
      color: white;
      margin-bottom: 20px;
    }
    
    .result-stats {
      display: flex;
      gap: 40px;
      justify-content: center;
      margin-bottom: 20px;
    }
    
    .stat-item {
      text-align: center;
    }
    
    .stat-label {
      font-size: 16px;
      color: #aaa;
      margin-bottom: 5px;
    }
    
    .stat-value {
      font-size: 28px;
      font-weight: bold;
    }
    
    .stat-value.perfect { color: #ffff00; }
    .stat-value.good { color: #00ff00; }
    .stat-value.miss { color: #ff0000; }
    .stat-value.combo { color: #ffd93d; }
    
    .result-buttons {
      display: flex;
      gap: 20px;
      margin-top: 20px;
    }
    
    .result-btn {
      padding: 15px 40px;
      font-size: 20px;
      font-weight: bold;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      transition: all 0.3s;
      pointer-events: auto;
    }
    
    .result-btn.retry {
      background: linear-gradient(135deg, #4d96ff, #6ba8ff);
      color: white;
      box-shadow: 0 5px 20px rgba(77, 150, 255, 0.4);
    }
    
    .result-btn.retry:hover {
      transform: scale(1.05);
      box-shadow: 0 8px 30px rgba(77, 150, 255, 0.6);
    }
    
    .result-btn.back {
      background: linear-gradient(135deg, #ff6b6b, #ff8e8e);
      color: white;
      box-shadow: 0 5px 20px rgba(255, 107, 107, 0.4);
    }
    
    .result-btn.back:hover {
      transform: scale(1.05);
      box-shadow: 0 8px 30px rgba(255, 107, 107, 0.6);
    }
  </style>
</head>
<body>
  <div id="game-container">
    <div id="video-area">
      <video id="video-bg"></video>
      <div id="loading">üéµ ÎπÑÌä∏ Î∂ÑÏÑù Ï§ë... Ïû†ÏãúÎßå Í∏∞Îã§Î†§Ï£ºÏÑ∏Ïöî!</div>
      <div id="countdown"></div>
    </div>
    
    <div id="notes-area">
      <canvas id="notes-layer"></canvas>
      <div id="ui-layer">
        <div id="score-display">SCORE: 0</div>
        <div id="combo-display">COMBO: 0</div>
        <div id="judgment-display"></div>
        <div id="key-hints">
          <div class="key-hint" data-key="D">D</div>
          <div class="key-hint" data-key="F">F</div>
        </div>
      </div>
    </div>
  </div>
  
  <div id="result-screen">
    <h2>üéâ Í≤∞Í≥º üéâ</h2>
    <div class="result-box">
      <div class="result-score" id="final-score">SCORE: 0</div>
      <div class="result-stats">
        <div class="stat-item">
          <div class="stat-label">PERFECT</div>
          <div class="stat-value perfect" id="perfect-count">0</div>
        </div>
        <div class="stat-item">
          <div class="stat-label">GOOD</div>
          <div class="stat-value good" id="good-count">0</div>
        </div>
        <div class="stat-item">
          <div class="stat-label">MISS</div>
          <div class="stat-value miss" id="miss-count">0</div>
        </div>
        <div class="stat-item">
          <div class="stat-label">MAX COMBO</div>
          <div class="stat-value combo" id="max-combo">0</div>
        </div>
      </div>
    </div>
    <div class="result-buttons">
      <button class="result-btn retry" id="retry-btn">üîÑ Îã§Ïãú ÌîåÎ†àÏù¥</button>
      <button class="result-btn back" id="back-btn">üè† Í≥° ÏÑ†ÌÉù</button>
    </div>
  </div>
  
  <script>
    // ========== Ìö®Í≥ºÏùå ÏÑ§Ï†ï ==========
    const SOUND_URL = {
      hit: "https://res.cloudinary.com/danknjfhv/video/upload/v1766607567/Firework_blast_far_w8escv.ogg"
    };
    
    let audioContext = null;
    let hitSoundBuffer = null;
    
    async function loadSounds() {
      try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const response = await fetch(SOUND_URL.hit);
        const arrayBuffer = await response.arrayBuffer();
        hitSoundBuffer = await audioContext.decodeAudioData(arrayBuffer);
      } catch (e) { console.log("Ìö®Í≥ºÏùå Î°úÎìú Ïã§Ìå®:", e); }
    }
    
    function playHitSound() {
      if (audioContext && hitSoundBuffer) {
        const source = audioContext.createBufferSource();
        source.buffer = hitSoundBuffer;
        const gainNode = audioContext.createGain();
        gainNode.gain.value = 5.0;
        source.connect(gainNode);
        gainNode.connect(audioContext.destination);
        source.start(0);
      }
    }
    
    // ========== BeatDetector ÌÅ¥ÎûòÏä§ (Î°±ÎÖ∏Ìä∏ ÏßÄÏõê) ==========
    class BeatDetector {
      constructor(options = {}) {
        this.threshold = options.threshold || 0.6;
        this.minInterval = options.minInterval || 300;
        this.vocalLowFreq = options.vocalLowFreq || 300;
        this.vocalHighFreq = options.vocalHighFreq || 3000;
        this.bassLowFreq = options.bassLowFreq || 20;
        this.bassHighFreq = options.bassHighFreq || 150;
        this.longNoteThreshold = options.longNoteThreshold || 0.5; // 0.5Ï¥à Ïù¥ÏÉÅÏù¥Î©¥ Î°±ÎÖ∏Ìä∏
      }

      async detectBeats(audioPath) {
        const tempContext = new (window.AudioContext || window.webkitAudioContext)();
        const response = await fetch(audioPath);
        const arrayBuffer = await response.arrayBuffer();
        const audioBuffer = await tempContext.decodeAudioData(arrayBuffer);
        
        const sampleRate = audioBuffer.sampleRate;
        const monoData = this.convertToMono(audioBuffer);
        
        const vocalPeaks = this.findFrequencyPeaksWithDuration(monoData, sampleRate, this.vocalLowFreq, this.vocalHighFreq, 'D');
        const bassPeaks = this.findFrequencyPeaksWithDuration(monoData, sampleRate, this.bassLowFreq, this.bassHighFreq, 'F');
        const volumePeaks = this.findVolumePeaksWithDuration(monoData, sampleRate);
        
        const allPeaks = [...vocalPeaks, ...bassPeaks, ...volumePeaks];
        allPeaks.sort((a, b) => a.time - b.time);
        
        const filteredNotes = this.filterCloseNotes(allPeaks);
        
        tempContext.close();
        return filteredNotes;
      }

      convertToMono(audioBuffer) {
        if (audioBuffer.numberOfChannels === 1) return audioBuffer.getChannelData(0);
        const left = audioBuffer.getChannelData(0);
        const right = audioBuffer.getChannelData(1);
        const mono = new Float32Array(left.length);
        for (let i = 0; i < left.length; i++) mono[i] = (left[i] + right[i]) / 2;
        return mono;
      }

      findFrequencyPeaksWithDuration(monoData, sampleRate, lowFreq, highFreq, key) {
        const peaks = [];
        const fftSize = 2048;
        const hopSize = Math.floor(sampleRate * 0.05);
        const minSamples = Math.floor(sampleRate * this.minInterval / 1000);
        
        let lastPeakSample = -minSamples;
        const energyHistory = [];
        
        for (let i = 0; i < monoData.length - fftSize; i += hopSize) {
          let bandEnergy = 0;
          for (let j = 0; j < fftSize; j++) {
            bandEnergy += Math.abs(monoData[i + j]);
          }
          bandEnergy /= fftSize;
          energyHistory.push({ sample: i, energy: bandEnergy });
        }
        
        const avgEnergy = energyHistory.reduce((sum, e) => sum + e.energy, 0) / energyHistory.length;
        const dynamicThreshold = avgEnergy * (1 + this.threshold);
        
        for (let i = 1; i < energyHistory.length - 1; i++) {
          const curr = energyHistory[i];
          const prev = energyHistory[i - 1];
          const next = energyHistory[i + 1];
          
          if (curr.energy > prev.energy && 
              curr.energy > next.energy && 
              curr.energy > dynamicThreshold &&
              (curr.sample - lastPeakSample) > minSamples) {
            
            // Î°±ÎÖ∏Ìä∏ duration Í≥ÑÏÇ∞: ÏóêÎÑàÏßÄÍ∞Ä ÏûÑÍ≥ÑÍ∞í Ïù¥ÏÉÅÏù∏ Íµ¨Í∞Ñ Í∏∏Ïù¥
            let duration = 0;
            let j = i + 1;
            while (j < energyHistory.length && energyHistory[j].energy > dynamicThreshold * 0.7) {
              j++;
            }
            const endSample = energyHistory[Math.min(j, energyHistory.length - 1)].sample;
            duration = (endSample - curr.sample) / sampleRate;
            
            // 0.5Ï¥à Ïù¥ÏÉÅÏù¥Î©¥ Î°±ÎÖ∏Ìä∏, ÏïÑÎãàÎ©¥ ÏùºÎ∞òÎÖ∏Ìä∏
            if (duration < this.longNoteThreshold) duration = 0;
            // ÏµúÎåÄ 3Ï¥àÎ°ú Ï†úÌïú
            if (duration > 3) duration = 3;
            
            peaks.push({ time: curr.sample / sampleRate, key, duration });
            lastPeakSample = curr.sample;
          }
        }
        
        return peaks;
      }

      findVolumePeaksWithDuration(monoData, sampleRate) {
        const peaks = [];
        const chunkSize = Math.floor(sampleRate * 0.1);
        const minSamples = Math.floor(sampleRate * this.minInterval / 1000);
        let lastPeakIndex = -minSamples;
        
        let totalSum = 0;
        for (let i = 0; i < monoData.length; i++) totalSum += Math.abs(monoData[i]);
        const dynamicThreshold = (totalSum / monoData.length) * (1.5 + this.threshold);
        
        const keys = ['D', 'F'];
        let keyIndex = 0;
        
        for (let i = 0; i < monoData.length; i += chunkSize) {
          let chunkSum = 0;
          const end = Math.min(i + chunkSize, monoData.length);
          for (let j = i; j < end; j++) chunkSum += Math.abs(monoData[j]);
          
          if ((chunkSum / (end - i)) > dynamicThreshold && (i - lastPeakIndex) > minSamples) {
            // Î≥ºÎ•® ÌîºÌÅ¨Îäî ÏùºÎ∞òÎÖ∏Ìä∏Î°úÎßå Ï≤òÎ¶¨
            peaks.push({ time: i / sampleRate, key: keys[keyIndex % 2], duration: 0 });
            keyIndex++;
            lastPeakIndex = i;
          }
        }
        
        return peaks;
      }

      filterCloseNotes(notes) {
        if (notes.length === 0) return [];
        
        const minGap = this.minInterval / 1000;
        const filtered = [notes[0]];
        
        for (let i = 1; i < notes.length; i++) {
          const lastNote = filtered[filtered.length - 1];
          // Î°±ÎÖ∏Ìä∏Ïù∏ Í≤ΩÏö∞ durationÎèÑ Í≥†Î†§
          const lastNoteEnd = lastNote.time + (lastNote.duration || 0);
          
          if (notes[i].time - lastNoteEnd >= minGap) {
            if (notes[i].key === lastNote.key) {
              notes[i].key = lastNote.key === 'D' ? 'F' : 'D';
            }
            filtered.push(notes[i]);
          }
        }
        
        return filtered;
      }
    }

    // ========== Í≤åÏûÑ ÏÑ§Ï†ï ==========
    const DIFFICULTY = { HARD: { threshold: 0.3, minInterval: 200 } };
    const LANE_KEYS = ['D', 'F'];
    const LANE_COLORS = ['#ff6b6b', '#4d96ff'];
    const NOTE_WIDTH = 90, NOTE_HEIGHT = 30;
    const HIT_LINE_Y_RATIO = 0.82;
    const NOTE_TRAVEL_TIME = 1.5;
    const COUNTDOWN_TIME = 3;
    
    const JUDGMENT = {
      PERFECT: { threshold: 300, score: 100, color: '#ffff00', text: 'PERFECT!' },
      GOOD: { threshold: 600, score: 50, color: '#00ff00', text: 'GOOD!' },
      MISS: { threshold: 800, score: 0, color: '#ff0000', text: 'MISS' }
    };
    
    // ========== Í≤åÏûÑ ÏÉÅÌÉú ==========
    let score = 0, combo = 0, maxCombo = 0;
    let perfectCount = 0, goodCount = 0, missCount = 0;
    let notes = [], isPlaying = false, hitLineY = 0, noteSpeed = 0, gameStartTime = 0;
    let currentSong = null;
    
    // Î°±ÎÖ∏Ìä∏ ÏÉÅÌÉú Ï∂îÏ†Å
    let heldKeys = { 'D': false, 'F': false };
    let activeLongNotes = {}; // ÌòÑÏû¨ ÌôÄÎî© Ï§ëÏù∏ Î°±ÎÖ∏Ìä∏ Ïù∏Îç±Ïä§
    
    // ========== DOM ÏöîÏÜå ==========
    const video = document.getElementById("video-bg");
    const canvas = document.getElementById("notes-layer");
    const ctx = canvas.getContext("2d");
    const scoreDisplay = document.getElementById("score-display");
    const comboDisplay = document.getElementById("combo-display");
    const judgmentDisplay = document.getElementById("judgment-display");
    const loadingDiv = document.getElementById("loading");
    const notesArea = document.getElementById("notes-area");
    const countdownDiv = document.getElementById("countdown");
    const resultScreen = document.getElementById("result-screen");
    const retryBtn = document.getElementById("retry-btn");
    const backBtn = document.getElementById("back-btn");
    
    retryBtn.addEventListener('click', retryGame);
    backBtn.addEventListener('click', backToSongSelect);
    
    function resizeCanvas() {
      canvas.width = notesArea.clientWidth;
      canvas.height = notesArea.clientHeight;
      hitLineY = canvas.height * HIT_LINE_Y_RATIO;
      noteSpeed = hitLineY / NOTE_TRAVEL_TIME;
    }
    
    function getLaneX(laneIndex) {
      const totalWidth = LANE_KEYS.length * (NOTE_WIDTH + 40);
      return (canvas.width - totalWidth) / 2 + laneIndex * (NOTE_WIDTH + 40);
    }
    
    function resetGame() {
      score = combo = maxCombo = perfectCount = goodCount = missCount = 0;
      notes = []; isPlaying = false;
      heldKeys = { 'D': false, 'F': false };
      activeLongNotes = {};
      updateUI();
    }
    
    async function startGameFlow() {
      resetGame();
      
      const songData = localStorage.getItem('selectedSong');
      if (!songData) {
        loadingDiv.textContent = "‚ö†Ô∏è Í≥° Ï†ïÎ≥¥Í∞Ä ÏóÜÏäµÎãàÎã§. Í≥° ÏÑ†ÌÉù ÌôîÎ©¥ÏúºÎ°ú ÎèåÏïÑÍ∞ÄÏÑ∏Ïöî.";
        return;
      }
      
      currentSong = JSON.parse(songData);
      
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);
      video.src = currentSong.videoUrl;
      video.crossOrigin = "anonymous";
      loadingDiv.style.display = "block";
      
      try {
        await loadSounds();
        const detector = new BeatDetector(DIFFICULTY.HARD);
        const detectedNotes = await detector.detectBeats(currentSong.videoUrl);
        notes = detectedNotes.map(note => ({
          ...note, 
          time: note.time + COUNTDOWN_TIME + NOTE_TRAVEL_TIME, 
          hit: false, 
          missed: false,
          duration: note.duration || 0,
          holdProgress: 0, // Î°±ÎÖ∏Ìä∏ ÌôÄÎî© ÏßÑÌñâÎèÑ
          holding: false   // ÌòÑÏû¨ ÌôÄÎî© Ï§ëÏù∏ÏßÄ
        }));
        console.log("Í∞êÏßÄÎêú ÎÖ∏Ìä∏ Ïàò:", notes.length);
        console.log("Î°±ÎÖ∏Ìä∏ Ïàò:", notes.filter(n => n.duration > 0).length);
        loadingDiv.style.display = "none";
        video.onended = showResult;
        startCountdown();
      } catch (e) {
        console.error(e);
        loadingDiv.textContent = "‚ö†Ô∏è Î∂ÑÏÑù Ïã§Ìå®! ÌéòÏù¥ÏßÄ ÏÉàÎ°úÍ≥†Ïπ® Ìï¥Ï£ºÏÑ∏Ïöî.";
      }
    }
    
    function startCountdown() {
      let count = 3;
      countdownDiv.style.display = 'block';
      countdownDiv.classList.add('active');
      countdownDiv.textContent = count;
      gameStartTime = Date.now() / 1000;
      isPlaying = true;
      render();
      
      const countInterval = setInterval(() => {
        count--;
        if (count > 0) {
          countdownDiv.textContent = count;
          countdownDiv.classList.remove('active');
          void countdownDiv.offsetWidth;
          countdownDiv.classList.add('active');
        } else if (count === 0) {
          countdownDiv.textContent = "GO!";
          countdownDiv.classList.remove('active');
          void countdownDiv.offsetWidth;
          countdownDiv.classList.add('active');
        } else {
          clearInterval(countInterval);
          countdownDiv.style.display = 'none';
          video.play();
        }
      }, 1000);
    }
    
    function render() {
      if (!isPlaying) return;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const currentTime = (Date.now() / 1000) - gameStartTime;
      
      // Î†àÏù∏ Î∞∞Í≤Ω
      LANE_KEYS.forEach((key, index) => {
        ctx.fillStyle = 'rgba(255,255,255,0.05)';
        ctx.fillRect(getLaneX(index) - 5, 0, NOTE_WIDTH + 10, canvas.height);
      });
      
      // ÌåêÏ†ïÏÑ†
      ctx.strokeStyle = "rgba(255, 255, 255, 0.8)";
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(getLaneX(0) - 20, hitLineY);
      ctx.lineTo(getLaneX(1) + NOTE_WIDTH + 20, hitLineY);
      ctx.stroke();
      
      // Î°±ÎÖ∏Ìä∏ ÌôÄÎî© ÏóÖÎç∞Ïù¥Ìä∏
      updateLongNotes(currentTime);
      
      // ÎÖ∏Ìä∏ Î†åÎçîÎßÅ
      notes.forEach((note, index) => {
        if (note.hit || note.missed) return;
        const laneIndex = LANE_KEYS.indexOf(note.key);
        if (laneIndex === -1) return;
        const x = getLaneX(laneIndex);
        const y = hitLineY - ((note.time - currentTime) * noteSpeed);
        
        // Î°±ÎÖ∏Ìä∏Ïù∏ Í≤ΩÏö∞
        if (note.duration > 0) {
          const noteLength = note.duration * noteSpeed;
          const noteTop = y - noteLength;
          
          // ÌôîÎ©¥ Î∞ñÏù¥Î©¥ Ïä§ÌÇµ
          if (noteTop > hitLineY + (JUDGMENT.MISS.threshold / 1000) * noteSpeed) {
            if (!note.holding) handleMiss(index);
            return;
          }
          if (y < -NOTE_HEIGHT) return;
          
          // Î°±ÎÖ∏Ìä∏ Î≥∏Ï≤¥ (Í∏∏Í≤å)
          const gradient = ctx.createLinearGradient(x, noteTop, x, y);
          gradient.addColorStop(0, LANE_COLORS[laneIndex]);
          gradient.addColorStop(1, LANE_COLORS[laneIndex] + 'aa');
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.roundRect(x, noteTop, NOTE_WIDTH, noteLength + NOTE_HEIGHT, 8);
          ctx.fill();
          
          // ÌôÄÎî© Ï§ëÏù¥Î©¥ ÏßÑÌñâÎèÑ ÌëúÏãú
          if (note.holding) {
            const progressHeight = noteLength * note.holdProgress;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.beginPath();
            ctx.roundRect(x, y - progressHeight, NOTE_WIDTH, progressHeight + NOTE_HEIGHT, 8);
            ctx.fill();
          }
          
          // ÌÖåÎëêÎ¶¨
          ctx.strokeStyle = "white";
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.roundRect(x, noteTop, NOTE_WIDTH, noteLength + NOTE_HEIGHT, 8);
          ctx.stroke();
          
          // Î°±ÎÖ∏Ìä∏ ÌëúÏãú (HOLD)
          ctx.fillStyle = "white";
          ctx.font = "bold 14px sans-serif";
          ctx.textAlign = "center";
          ctx.fillText("HOLD", x + NOTE_WIDTH/2, noteTop + 20);
          ctx.fillText(note.key, x + NOTE_WIDTH/2, y + NOTE_HEIGHT/2 + 6);
          
        } else {
          // ÏùºÎ∞ò ÎÖ∏Ìä∏
          if (y < -NOTE_HEIGHT) return;
          if (y > hitLineY + (JUDGMENT.MISS.threshold / 1000) * noteSpeed) { handleMiss(index); return; }
          
          ctx.fillStyle = LANE_COLORS[laneIndex];
          ctx.beginPath();
          ctx.roundRect(x, y, NOTE_WIDTH, NOTE_HEIGHT, 8);
          ctx.fill();
          ctx.strokeStyle = "white";
          ctx.lineWidth = 2;
          ctx.stroke();
          ctx.fillStyle = "white";
          ctx.font = "bold 18px sans-serif";
          ctx.textAlign = "center";
          ctx.fillText(note.key, x + NOTE_WIDTH/2, y + NOTE_HEIGHT/2 + 6);
        }
      });
      
      requestAnimationFrame(render);
    }
    
    function updateLongNotes(currentTime) {
      notes.forEach((note, index) => {
        if (note.hit || note.missed || note.duration <= 0) return;
        
        // Î°±ÎÖ∏Ìä∏ ÌôÄÎî© Ï§ëÏù∏ Í≤ΩÏö∞
        if (note.holding && heldKeys[note.key]) {
          const holdTime = currentTime - note.holdStartTime;
          note.holdProgress = Math.min(holdTime / note.duration, 1);
          
          // ÌôÄÎî© ÏôÑÎ£å
          if (note.holdProgress >= 1) {
            handleLongNoteComplete(index);
          }
        }
        
        // ÌôÄÎî© Ï§ëÏù∏Îç∞ ÌÇ§Î•º ÎóÄ Í≤ΩÏö∞
        if (note.holding && !heldKeys[note.key]) {
          if (note.holdProgress < 0.5) {
            // 50% ÎØ∏ÎßåÏù¥Î©¥ MISS
            handleMiss(index);
          } else {
            // 50% Ïù¥ÏÉÅÏù¥Î©¥ GOOD
            handleLongNotePartial(index);
          }
        }
      });
    }
    
    function handleKeyPress(key) {
      if (!isPlaying) return;
      const currentTime = (Date.now() / 1000) - gameStartTime;
      const keyUpper = key.toUpperCase();
      
      let closestNote = null, closestDiff = Infinity, closestIndex = -1;
      
      notes.forEach((note, index) => {
        if (note.hit || note.missed || note.key !== keyUpper || note.holding) return;
        const diff = Math.abs(note.time - currentTime) * 1000;
        if (diff < closestDiff) { closestDiff = diff; closestNote = note; closestIndex = index; }
      });
      
      if (!closestNote) return;
      
      // Î°±ÎÖ∏Ìä∏Ïù∏ Í≤ΩÏö∞
      if (closestNote.duration > 0) {
        if (closestDiff <= JUDGMENT.GOOD.threshold) {
          // Î°±ÎÖ∏Ìä∏ ÌôÄÎî© ÏãúÏûë
          notes[closestIndex].holding = true;
          notes[closestIndex].holdStartTime = currentTime;
          activeLongNotes[keyUpper] = closestIndex;
          playHitSound();
          showJudgment("HOLD!", '#00ffff');
        } else if (closestDiff <= JUDGMENT.MISS.threshold) {
          handleMiss(closestIndex);
        }
      } else {
        // ÏùºÎ∞ò ÎÖ∏Ìä∏
        if (closestDiff <= JUDGMENT.PERFECT.threshold) { 
          handleHit(closestIndex, JUDGMENT.PERFECT); 
          perfectCount++; 
        }
        else if (closestDiff <= JUDGMENT.GOOD.threshold) { 
          handleHit(closestIndex, JUDGMENT.GOOD); 
          goodCount++; 
        }
        else if (closestDiff <= JUDGMENT.MISS.threshold) { 
          handleMiss(closestIndex); 
        }
      }
    }
    
    function handleKeyRelease(key) {
      const keyUpper = key.toUpperCase();
      
      // Î°±ÎÖ∏Ìä∏ ÌôÄÎî© Ï§ëÏù¥ÏóàÎã§Î©¥ updateLongNotesÏóêÏÑú Ï≤òÎ¶¨Îê®
    }
    
    function handleLongNoteComplete(index) {
      notes[index].hit = true;
      notes[index].holding = false;
      combo++;
      if (combo > maxCombo) maxCombo = combo;
      score += JUDGMENT.PERFECT.score * 2 * (1 + combo * 0.01); // Î°±ÎÖ∏Ìä∏Îäî 2Î∞∞ Ï†êÏàò
      perfectCount++;
      delete activeLongNotes[notes[index].key];
      playHitSound();
      updateUI();
      showJudgment(JUDGMENT.PERFECT.text, JUDGMENT.PERFECT.color);
    }
    
    function handleLongNotePartial(index) {
      notes[index].hit = true;
      notes[index].holding = false;
      combo++;
      if (combo > maxCombo) maxCombo = combo;
      score += JUDGMENT.GOOD.score * (1 + combo * 0.01);
      goodCount++;
      delete activeLongNotes[notes[index].key];
      updateUI();
      showJudgment(JUDGMENT.GOOD.text, JUDGMENT.GOOD.color);
    }
    
    function handleHit(index, judgment) {
      notes[index].hit = true;
      combo++;
      if (combo > maxCombo) maxCombo = combo;
      score += judgment.score * (1 + combo * 0.01);
      playHitSound();
      updateUI();
      showJudgment(judgment.text, judgment.color);
    }
    
    function handleMiss(index) {
      notes[index].missed = true;
      notes[index].holding = false;
      if (activeLongNotes[notes[index].key] === index) {
        delete activeLongNotes[notes[index].key];
      }
      combo = 0;
      missCount++;
      updateUI();
      showJudgment(JUDGMENT.MISS.text, JUDGMENT.MISS.color);
    }
    
    function updateUI() {
      scoreDisplay.textContent = "SCORE: " + Math.floor(score);
      comboDisplay.textContent = "COMBO: " + combo;
    }
    
    function showJudgment(text, color) {
      judgmentDisplay.textContent = text;
      judgmentDisplay.style.color = color;
      judgmentDisplay.style.opacity = 1;
      setTimeout(() => { judgmentDisplay.style.opacity = 0; }, 300);
    }
    
    function showResult() {
      isPlaying = false;
      video.pause();
      document.getElementById('final-score').textContent = "SCORE: " + Math.floor(score);
      document.getElementById('perfect-count').textContent = perfectCount;
      document.getElementById('good-count').textContent = goodCount;
      document.getElementById('miss-count').textContent = missCount;
      document.getElementById('max-combo').textContent = maxCombo;
      resultScreen.classList.add('active');
    }
    
    function retryGame() {
      resultScreen.classList.remove('active');
      video.currentTime = 0;
      startGameFlow();
    }
    
    function backToSongSelect() {
      window.location.href = 'index.html';
    }
    
    document.addEventListener("keydown", (e) => {
      const key = e.key.toUpperCase();
      if (LANE_KEYS.includes(key)) {
        if (!heldKeys[key]) { // ÌÇ§ Î∞òÎ≥µ Î∞©ÏßÄ
          heldKeys[key] = true;
          handleKeyPress(key);
        }
        const hint = document.querySelector(`.key-hint[data-key="${key}"]`);
        if (hint) hint.classList.add("active");
      }
    });
    
    document.addEventListener("keyup", (e) => {
      const key = e.key.toUpperCase();
      if (LANE_KEYS.includes(key)) {
        heldKeys[key] = false;
        handleKeyRelease(key);
      }
      const hint = document.querySelector(`.key-hint[data-key="${key}"]`);
      if (hint) hint.classList.remove("active");
    });
    
    window.onload = startGameFlow;
  </script>
</body>
</html>